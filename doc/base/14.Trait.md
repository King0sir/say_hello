### Trait

---

> * 类可以实现任意多个特质
> * 特质可以要求实现它们的类具备特定的字段,方法或者超类
> * Scala 特质可以提供方法和字段的实现
> * 多个特质叠加在一起的时候,顺序会导致—后面的特质的方法更优先执行

特质可以像 java 中的接口一样工作,例如:

```scala
trait Logger{
  def log(msg:String) 	//这是个抽象方法
}
```

在 scala 中,没有被实现的方法就是抽象方法,它并不需要声明为 abstract 标签.

子类可以实现特质的方法

```scala
class ConsoleLogger extends Logger{
  def log(msg:String){println(msg)} 	//不需要给出 Override
}
```

```scala
class ConsoleLogger extends Logger with Cloneable with Serializble
```

scala 类只能有一个超类,但是特质可以有任意数量.

---

##### 带有实现的特质

特质的方法不一定是抽象的:

```scala
trait ConsoleLogger {
  def log(msg:String){println(msg)}
}
```

```scala
class SavingAccount extends Account with ConsoleLogger{
  def withdraw(amount:Double){
    if(amount > balance) log("Insufficient funds")
    else balance -= amount
  }
  ...
}
```

这就是 SavingsAccount 从 ConsoleLogger得到了一个具体的 log方法实现.

---

##### 带有特质的对象

```scala
trait Logged{
  def log(msg:String){}
}
```

这种情况下我们可以再类的定义中使用这个特质:

```scala
class SavingAccount extends Account with Logged {
  def withdraw(amount:Double){
    if(amount > balance) log("Insufficient funds")
    else ...
  }
  ...
}
```

但是这样的定义会导致没有任何东西被打印出来.我们可以再类的构造中混入一个类的定义.比如:

```scala
trait ConsoleLogger extends Logged{
  override def log(msg:String) {println(msg)}
}
```

于是我们可以在构造对象的时候加入这样一个特质:

```scala
val acct = new SavingAccount with ConsoleLogger
```

这样我们在调用的时候就会自动的套用对应的方法;

同样的我们也可以加入另一个特质

```scala
val acct2 = new SavingAccount with FileLogger
```

---

##### 特质的叠加

特质的顺序十分重要比如对我们给出的如下两个特质:

```scala
trait TimestampLogger extends Logged {
  override def log(msg:String){
    super.log(new java.util.Date() + " "+ msg)
  }
}

trait ShortLogger extends Logged{
  val maxLength = 15
  override def log(msg:String){
    super.log(
   	  if(msg.length <= maxLength)msg else msg.substring(0,maxlength-3) + "...")
    )
  }
}
```

对于这两个特质,我们给出如下的两个例子:

```scala
val acct1 = new SavingAccount with ConsoleLogger with TimestampLogger with ShortLogger
  //Sun Feb 06 17:45:45 ICT 2011 Insufficient...
  //它先把log缩短再加上时间戳
val acct2 = new SavingAccount with ConsoleLogger with ShortLogger with TimestampLogger
  //Sun Feb 06 1...
  //先加上时间戳之后缩短
```

---

##### 在特质中重写抽象方法

对于之前的特质:

```scala
trait Logger {
  def log (msg :String)	//抽象方法
}
```

我们用时间戳特质来拓展它,:

```scala
trait TimestampLogger extends Logger {
  override def log (msg:String){
    super.log(new java.util.Date() + " "+ msg)	//super.log 还没有定义
  }
}
```

所以对于这个,编译器会首先报错,我们需要他是抽象的:

对于这种情况我们需要给它加上 abstract 和 override 标签

```scala
trait TimestampLogger extends Logger {
  abstract override def log (msg:String){
    super.log(new java.util.Date() + " "+ msg)	//super.log 还没有定义
  }
}
```

---

##### 当做富接口使用的特质

我们可以使特质含有丰富的工具方法:

```scala
trait Logger {
  def log(msg:String)
  def info(msg:String){log("INFO: "+msg)}
  def warn(msg:String){log("WARN: "+msg)}
  def severe(msg:String){log("SEVERE: "+msg)}
}
```

在这里我们的所有方法都是没有实现的,但是我们可以在追加中实现这些:

```scala
class SavingAccount extends Account with Logger{
  def withdraw(amount:Double){
    if(amount > balance) severe("Insufficient funds")
    else ...
  }
  ...
  override def log(msg:String){println(msg)}
}
```

像这样就可使我们的特质方法都获得实现;

---

