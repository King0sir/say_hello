### Trait

---

> * 类可以实现任意多个特质
> * 特质可以要求实现它们的类具备特定的字段,方法或者超类
> * Scala 特质可以提供方法和字段的实现
> * 多个特质叠加在一起的时候,顺序会导致—后面的特质的方法更优先执行

特质可以像 java 中的接口一样工作,例如:

```scala
trait Logger{
  def log(msg:String) 	//这是个抽象方法
}
```

在 scala 中,没有被实现的方法就是抽象方法,它并不需要声明为 abstract 标签.

子类可以实现特质的方法

```scala
class ConsoleLogger extends Logger{
  def log(msg:String){println(msg)} 	//不需要给出 Override
}
```

```scala
class ConsoleLogger extends Logger with Cloneable with Serializble
```

scala 类只能有一个超类,但是特质可以有任意数量.

---

##### 带有实现的特质

特质的方法不一定是抽象的:

```scala
trait ConsoleLogger {
  def log(msg:String){println(msg)}
}
```

```scala
class SavingAccount extends Account with ConsoleLogger{
  def withdraw(amount:Double){
    if(amount > balance) log("Insufficient funds")
    else balance -= amount
  }
  ...
}
```

这就是 SavingsAccount 从 ConsoleLogger得到了一个具体的 log方法实现.

---

##### 带有特质的对象

```scala
trait Logged{
  def log(msg:String){}
}
```

这种情况下我们可以再类的定义中使用这个特质:

```scala
class SavingAccount extends Account with Logged {
  def withdraw(amount:Double){
    if(amount > balance) log("Insufficient funds")
    else ...
  }
  ...
}
```

但是这样的定义会导致没有任何东西被打印出来.我们可以再类的构造中混入一个类的定义.比如:

```scala
trait ConsoleLogger extends Logged{
  override def log(msg:String) {println(msg)}
}
```

于是我们可以在构造对象的时候加入这样一个特质:

```scala
val acct = new SavingAccount with ConsoleLogger
```

这样我们在调用的时候就会自动的套用对应的方法;

同样的我们也可以加入另一个特质

```scala
val acct2 = new SavingAccount with FileLogger
```



